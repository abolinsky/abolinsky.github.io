<!doctype html>
<html>

<head>
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="chrome=1">
  <title>abolinsky.github.io by abolinsky</title>

  <link rel="stylesheet" href="stylesheets/styles.css">
  <link rel="stylesheet" href="stylesheets/pygment_trac.css">
  <meta name="viewport" content="width=device-width, initial-scale=1, user-scalable=no">
  <!--[if lt IE 9]>
  <script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script>
  <![endif]-->
  <style type="text/css"> </style>
</head>

<body>
  <canvas id="canvas" style="position: absolute; top: 0vh; left: 0vw; background-color: #000"></canvas>
  <script>

  // Find intersection of RAY & SEGMENT
  function getIntersection(ray,segment){
    // RAY in parametric: Point + Delta*T1
    var r_px = ray.a.x;
    var r_py = ray.a.y;
    var r_dx = ray.b.x-ray.a.x;
    var r_dy = ray.b.y-ray.a.y;
    // SEGMENT in parametric: Point + Delta*T2
    var s_px = segment.a.x;
    var s_py = segment.a.y;
    var s_dx = segment.b.x-segment.a.x;
    var s_dy = segment.b.y-segment.a.y;
    // Are they parallel? If so, no intersect
    var r_mag = Math.sqrt(r_dx*r_dx+r_dy*r_dy);
    var s_mag = Math.sqrt(s_dx*s_dx+s_dy*s_dy);
    if(r_dx/r_mag==s_dx/s_mag && r_dy/r_mag==s_dy/s_mag){
      // Unit vectors are the same.
      return null;
    }
    var T2 = (r_dx*(s_py-r_py) + r_dy*(r_px-s_px))/(s_dx*r_dy - s_dy*r_dx);
    var T1 = (s_px+s_dx*T2-r_px)/r_dx;
    // Must be within parametic whatevers for RAY/SEGMENT
    if(T1<0) return null;
    if(T2<0 || T2>1) return null;
    // Return the POINT OF INTERSECTION
    return {
      x: r_px+r_dx*T1,
      y: r_py+r_dy*T1,
      param: T1
    };
  }
  function getSightPolygon(sightX,sightY){
    // Get all unique points
    var points = (function(segments){
      var a = [];
      segments.forEach(function(seg){
        a.push(seg.a,seg.b);
      });
      return a;
    })(segments);
    var uniquePoints = (function(points){
      var set = {};
      return points.filter(function(p){
        var key = p.x+","+p.y;
        if(key in set){
          return false;
        }else{
          set[key]=true;
          return true;
        }
      });
    })(points);
    // Get all angles
    var uniqueAngles = [];
    for(var j=0;j<uniquePoints.length;j++){
      var uniquePoint = uniquePoints[j];
      var angle = Math.atan2(uniquePoint.y-sightY,uniquePoint.x-sightX);
      uniquePoint.angle = angle;
      uniqueAngles.push(angle-0.00001,angle,angle+0.00001);
    }
    // RAYS IN ALL DIRECTIONS
    var intersects = [];
    for(var j=0;j<uniqueAngles.length;j++){
      var angle = uniqueAngles[j];
      // Calculate dx & dy from angle
      var dx = Math.cos(angle);
      var dy = Math.sin(angle);
      // Ray from center of screen to mouse
      var ray = {
        a:{x:sightX,y:sightY},
        b:{x:sightX+dx,y:sightY+dy}
      };
      // Find CLOSEST intersection
      var closestIntersect = null;
      for(var i=0;i<segments.length;i++){
        var intersect = getIntersection(ray,segments[i]);
        if(!intersect) continue;
        if(!closestIntersect || intersect.param<closestIntersect.param){
          closestIntersect=intersect;
        }
      }
      // Intersect angle
      if(!closestIntersect) continue;
      closestIntersect.angle = angle;
      // Add to list of intersects
      intersects.push(closestIntersect);
    }
    // Sort intersects by angle
    intersects = intersects.sort(function(a,b){
      return a.angle-b.angle;
    });
    // Polygon is intersects, in order of angle
    return intersects;
  }
  ///////////////////////////////////////////////////////
  // DRAWING
  var canvas = document.getElementById("canvas");
  var ctx = canvas.getContext("2d");
  canvas.width = window.innerWidth;
  canvas.height = window.innerHeight;

  var posOfLight = canvas.height+15;
  var activateMouse = 0;

  function calculateTheta() {
    var x = Math.abs((canvas.width/2)-Mouse.x);
    var y = Mouse.y;
    var theta = Math.atan(y/x);
    return theta;
  }

  function draw(){
    // Clear canvas
    ctx.clearRect(0,0,canvas.width,canvas.height);
    // Draw segments
    if (activateMouse) {
      ctx.strokeStyle = "#FFF";
    } else {
      ctx.strokeStyle = "#000";
    }
    ctx.fillStyle = "#ffd700";
    for(var i=0;i<segments.length;i++){
      var seg = segments[i];
      ctx.beginPath();
      ctx.moveTo(seg.a.x,seg.a.y);
      ctx.lineTo(seg.b.x,seg.b.y);
      if (i === 6 || i === 7 || i === 10 || i === 11) {
        ctx.stroke();
      }
    }
    ctx.fill();

    // Sight Polygons
    var fuzzyRadius = 20;
    if (!activateMouse || activateMouse) {
      var polygons = [getSightPolygon((canvas.width/2),posOfLight+50)];
    } else {
      if (Mouse.x < canvas.width/2) {
        var polygons = [getSightPolygon((canvas.width/2)-(100*Math.cos(calculateTheta())),100*Math.sin(calculateTheta()))];
      } else {
        var polygons = [getSightPolygon((canvas.width/2)+(100*Math.cos(calculateTheta())),100*Math.sin(calculateTheta()))];
      }
    }

    for(var angle=0;angle<Math.PI*2;angle+=(Math.PI*2)/10){
      var dx = Math.cos(angle)*fuzzyRadius;
      var dy = Math.sin(angle)*fuzzyRadius;

      if (!activateMouse || activateMouse) {
        polygons.push(getSightPolygon((canvas.width/2)+dx,posOfLight+50+dy));
      } else {
        if (Mouse.x < canvas.width/2) {
          polygons.push(getSightPolygon((canvas.width/2)-(100*Math.cos(calculateTheta()))+dx,100*Math.sin(calculateTheta())+dy));
        } else {
          polygons.push(getSightPolygon((canvas.width/2)+(100*Math.cos(calculateTheta()))+dx,100*Math.sin(calculateTheta())+dy));
        }
      }
    };

    // DRAW AS A GIANT POLYGON
    if (activateMouse) {
      for(var i=1;i<polygons.length;i++){
        drawPolygon(polygons[i],ctx,"rgba(255,255,255,0.1)");
      }
      drawPolygon(polygons[0],ctx,"#EEB422");
    }

    // Light rising
    // Draw red dots
    if (activateMouse) {
      ctx.fillStyle = "#ffd700";
    } else {
      ctx.fillStyle = "#333";
    }
    ctx.beginPath();
    if (!activateMouse || activateMouse) {
      ctx.arc((canvas.width/2), posOfLight+50, 10, 0, 2*Math.PI, false);
    } else {
      if (Mouse.x < canvas.width/2) {
        ctx.arc((canvas.width/2)-(100*Math.cos(calculateTheta())), 100*Math.sin(calculateTheta()), 10, 0, 2*Math.PI, false);
      } else {
        ctx.arc((canvas.width/2)+(100*Math.cos(calculateTheta())), 100*Math.sin(calculateTheta()), 10, 0, 2*Math.PI, false);
      }
    }
    ctx.fill();
    for(var angle=0;angle<Math.PI*2;angle+=(Math.PI*2)/10){
      var dx = Math.cos(angle)*fuzzyRadius;
      var dy = Math.sin(angle)*fuzzyRadius;
      ctx.beginPath();
      if (!activateMouse || activateMouse) {
        ctx.arc((canvas.width/2), posOfLight+50, 2, 0, 2*Math.PI, false);
      } else {
        if (Mouse.x < canvas.width/2) {
          ctx.arc((canvas.width/2)-(100*Math.cos(calculateTheta())), 100*Math.sin(calculateTheta()), 2, 0, 2*Math.PI, false);
        } else {
          ctx.arc((canvas.width/2)+(100*Math.cos(calculateTheta())), 100*Math.sin(calculateTheta()), 2, 0, 2*Math.PI, false);
        }
      }
      ctx.fill();
    }

      if (posOfLight > .5) {
        posOfLight -= posOfLight/(canvas.height/9);
      } else {
        activateMouse = 1;
      }

        ctx.font = "18px Calibri";
        ctx.strokeStyle = "#000";
        ctx.strokeText("Resume", (canvas.width/2)-200, (canvas.height/2));
        if (activateMouse) {
          ctx.fillStyle = "#FFF";
        } else {
          ctx.fillStyle = "#000";
        }
        ctx.fillText("Resume", (canvas.width/2)-200, (canvas.height/2));
        ctx.textAlign = "center";

        ctx.font = "18px Calibri";
        ctx.strokeStyle = "#000";
        ctx.strokeText("Projects", (canvas.width/2)+200, (canvas.height/2));
        if (activateMouse) {
          ctx.fillStyle = "#FFF";
        } else {
          ctx.fillStyle = "#000";
        }
        ctx.fillText("Projects", (canvas.width/2)+200, (canvas.height/2));
        ctx.textAlign = "center";

        ctx.strokeStyle = "#999";
        ctx.lineWidth = "2";
        ctx.beginPath();
        ctx.moveTo(canvas.width/2,-1);
        if (!activateMouse || activateMouse) {
          ctx.lineTo(canvas.width/2,posOfLight+40);
        } else {
          if (Mouse.x < canvas.width/2) {
            ctx.lineTo((canvas.width/2)-(90*Math.cos(calculateTheta())),90*Math.sin(calculateTheta()));
          } else {
            ctx.lineTo((canvas.width/2)+(90*Math.cos(calculateTheta())),90*Math.sin(calculateTheta()));
          }
        }
        ctx.stroke();

        if (activateMouse) {
          ctx.font = "120px Calibri";
          ctx.fillStyle = "#000";
          ctx.fillText("Alexander Bolinsky", canvas.width/2, 165);
          ctx.textAlign = "center";
        }
  }

  function drawPolygon(polygon,ctx,fillStyle){
    ctx.fillStyle = fillStyle;
    ctx.beginPath();
    ctx.moveTo(polygon[0].x,polygon[0].y);
    for(var i=1;i<polygon.length;i++){
      var intersect = polygon[i];
      ctx.lineTo(intersect.x,intersect.y);
    }
    ctx.fill();
  }

  // LINE SEGMENTS
  var segments = [
  // Border
  {a:{x:-1,y:-1}, b:{x:-1,y:canvas.height+1}},
  {a:{x:-1,y:canvas.height+1}, b:{x:canvas.width+1,y:canvas.height+1}},
  {a:{x:canvas.width+1,y:canvas.height+1}, b:{x:canvas.width+1,y:-1}},
  {a:{x:canvas.width+1,y:-1}, b:{x:-1,y:-1}},

  // Resume
  {a:{x:(canvas.width/2)-300,y:(canvas.height/2)-90}, b:{x:(canvas.width/2)-100,y:(canvas.height/2)-90}},
  {a:{x:(canvas.width/2)-100,y:(canvas.height/2)-90}, b:{x:(canvas.width/2)-100,y:(canvas.height/2)+210}},
  {a:{x:(canvas.width/2)-100,y:(canvas.height/2)+210}, b:{x:(canvas.width/2)-300,y:(canvas.height/2)+210}},
  {a:{x:(canvas.width/2)-300,y:(canvas.height/2)+210}, b:{x:(canvas.width/2)-300,y:(canvas.height/2)-90}},

  // Projects
  {a:{x:(canvas.width/2)+300,y:(canvas.height/2)-90}, b:{x:(canvas.width/2)+100,y:(canvas.height/2)-90}},
  {a:{x:(canvas.width/2)+100,y:(canvas.height/2)-90}, b:{x:(canvas.width/2)+100,y:(canvas.height/2)+210}},
  {a:{x:(canvas.width/2)+100,y:(canvas.height/2)+210}, b:{x:(canvas.width/2)+300,y:(canvas.height/2)+210}},
  {a:{x:(canvas.width/2)+300,y:(canvas.height/2)+210}, b:{x:(canvas.width/2)+300,y:(canvas.height/2)-90}},

  ];

  window.onload = setInterval(draw,1);

  // MOUSE
  var Mouse = {
    x: canvas.width/2,
    y: canvas.height/2
  };

  canvas.onmousemove = function(event){
    Mouse.x = event.clientX;
    Mouse.y = event.clientY;
  };

  </script>
</body>
</html>
